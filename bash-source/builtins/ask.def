This file is ask.def, from which is created ask.c.
It implements the baish builtin "ask".

Copyright (C) 2026

$PRODUCES ask.c

#include <config.h>

#include "../bashtypes.h"
#include "../bashansi.h"

#include <errno.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

#include "../shell.h"
#include "../bashintl.h"
#include "../variables.h"
#include "../xmalloc.h"

#include "common.h"

$BUILTIN ask
$FUNCTION ask_builtin
$SHORT_DOC ask [question...]
Ask the configured model a question; optionally execute returned shell commands.

Configuration variables:
  BAISH_OPENAI_BASE_URL  Host or base URL (e.g. puck.local, puck.local:8000, http://puck.local/v1)
  BAISH_OPENAI_PORT      Optional port override (ignored if BAISH_OPENAI_BASE_URL includes an explicit port)
  BAISH_MODEL            Model name
  BAISH_AUTOEXEC         If set (non-zero), execute returned commands without prompting
  BAISH_FAIL_FAST         If set (non-zero), preflight the LLM (/models) before sending the prompt
  OPENAI_API_KEY         Optional bearer token

Compatibility:
  OPENAI_BASE_URL         Fallback for BAISH_OPENAI_BASE_URL
  OPENAI_MODEL            Fallback for BAISH_MODEL

Results variables:
  BAISH_LAST_ANSWER      Last answer string
  BAISH_LAST_COMMANDS    Newline-separated commands (if any)

The model is asked to return JSON: {"answer":..., "commands":[...]}. If parsing
fails, the raw model content is used as the answer.
$END

static const char *
baish_skip_ws (const char *p)
{
  while (p && (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n'))
    p++;
  return p;
}

static int
baish_truthy (const char *s)
{
  if (s == 0)
    return 0;
  s = baish_skip_ws (s);
  if (*s == 0)
    return 0;
  if (STREQ (s, "0") || STREQ (s, "false") || STREQ (s, "FALSE") || STREQ (s, "no") || STREQ (s, "NO"))
    return 0;
  return 1;
}

static int
baish_ascii_tolower (int c)
{
  if (c >= 'A' && c <= 'Z')
    return c + ('a' - 'A');
  return c;
}

static const char *
baish_strcasestr (const char *haystack, const char *needle)
{
  size_t nlen;
  const char *h;

  if (haystack == 0 || needle == 0)
    return 0;
  nlen = strlen (needle);
  if (nlen == 0)
    return haystack;

  for (h = haystack; *h; h++)
    {
      size_t i;
      for (i = 0; i < nlen; i++)
        {
          if (h[i] == 0)
            break;
          if (baish_ascii_tolower ((unsigned char)h[i]) != baish_ascii_tolower ((unsigned char)needle[i]))
            break;
        }
      if (i == nlen)
        return h;
    }
  return 0;
}

static char baish_transport_error[256];

static void
baish_clear_transport_error (void)
{
  baish_transport_error[0] = '\0';
}

static void
baish_set_transport_error (const char *fmt, ...)
{
  va_list ap;

  if (fmt == 0)
    {
      baish_transport_error[0] = '\0';
      return;
    }

  va_start (ap, fmt);
  vsnprintf (baish_transport_error, sizeof (baish_transport_error), fmt, ap);
  va_end (ap);
}

static int
baish_diag_enabled (void)
{
  return (interactive_shell && isatty (fileno (stderr)));
}

static void
baish_diag (const char *fmt, ...)
{
  va_list ap;

  if (baish_diag_enabled () == 0)
    return;
  if (fmt == 0)
    return;

  fprintf (stderr, "baish: ");
  va_start (ap, fmt);
  vfprintf (stderr, fmt, ap);
  va_end (ap);
  fprintf (stderr, "\n");
  fflush (stderr);
}

static int
baish_http_timeout_seconds (void)
{
  const char *s;
  long v;

  s = get_string_value ("BAISH_HTTP_TIMEOUT_SECS");
  if (s == 0 || *s == 0)
    return 15;

  v = strtol (s, 0, 10);
  if (v < 1)
    return 15;
  if (v > 600)
    return 600;
  return (int)v;
}

static char *
baish_slurp_stream (FILE *fp, size_t *lenp)
{
  size_t cap, len;
  char *buf;
  size_t n;

  cap = 4096;
  len = 0;
  buf = (char *)xmalloc (cap);

  while (1)
    {
      if (len + 2048 >= cap)
        {
          cap *= 2;
          buf = (char *)xrealloc (buf, cap);
        }
      n = fread (buf + len, 1, cap - len - 1, fp);
      if (n == 0)
        break;
      len += n;
    }

  buf[len] = '\0';
  if (lenp)
    *lenp = len;
  return buf;
}

static char *
baish_json_escape (const char *s)
{
  size_t i, o, cap;
  char *out;

  if (s == 0)
    return savestring ("");

  cap = strlen (s) * 2 + 32;
  out = (char *)xmalloc (cap);
  o = 0;

  for (i = 0; s[i]; i++)
    {
      unsigned char c = (unsigned char)s[i];
      if (o + 8 >= cap)
        {
          cap *= 2;
          out = (char *)xrealloc (out, cap);
        }
      switch (c)
        {
        case '\\': out[o++]='\\'; out[o++]='\\'; break;
        case '"': out[o++]='\\'; out[o++]='"'; break;
        case '\b': out[o++]='\\'; out[o++]='b'; break;
        case '\f': out[o++]='\\'; out[o++]='f'; break;
        case '\n': out[o++]='\\'; out[o++]='n'; break;
        case '\r': out[o++]='\\'; out[o++]='r'; break;
        case '\t': out[o++]='\\'; out[o++]='t'; break;
        default:
          if (c < 0x20)
            {
              static const char hex[] = "0123456789abcdef";
              out[o++]='\\'; out[o++]='u'; out[o++]='0'; out[o++]='0';
              out[o++]=hex[(c>>4)&0xf];
              out[o++]=hex[c&0xf];
            }
          else
            out[o++] = (char)c;
          break;
        }
    }
  out[o] = '\0';
  return out;
}

static char *
baish_json_parse_string (const char **pp)
{
  const char *p;
  size_t cap, o;
  char *out;

  p = *pp;
  if (p == 0 || *p != '"')
    return 0;
  p++;

  cap = 128;
  out = (char *)xmalloc (cap);
  o = 0;

  while (*p)
    {
      unsigned char c = (unsigned char)*p++;
      if (c == '"')
        break;
      if (c == '\\')
        {
          unsigned char e = (unsigned char)*p++;
          switch (e)
            {
            case '"': c = '"'; break;
            case '\\': c = '\\'; break;
            case '/': c = '/'; break;
            case 'b': c = '\b'; break;
            case 'f': c = '\f'; break;
            case 'n': c = '\n'; break;
            case 'r': c = '\r'; break;
            case 't': c = '\t'; break;
            case 'u':
              if (p[0] && p[1] && p[2] && p[3])
                p += 4;
              c = '?';
              break;
            default:
              c = e;
              break;
            }
        }

      if (o + 2 >= cap)
        {
          cap *= 2;
          out = (char *)xrealloc (out, cap);
        }
      out[o++] = (char)c;
    }

  out[o] = '\0';
  *pp = p;
  return out;
}

static int
baish_parse_http_base_url (const char *base, char **hostp, char **portp, char **pathp, int *explicit_portp)
{
  const char *p, *host_start;
  const char *host_end, *port_start, *path_start;
  char *host, *port, *path;
  int explicit_port;

  if (base == 0)
    return 0;

  p = base;
  if (STREQN (p, "http://", 7))
    p += 7;
  else if (STREQN (p, "https://", 8))
    return 0; /* no TLS support */

  explicit_port = 0;

  host_start = p;
  while (*p && *p != ':' && *p != '/')
    p++;
  host_end = p;
  if (host_end == host_start)
    return 0;

  port_start = 0;
  if (*p == ':')
    {
      p++;
      port_start = p;
      while (*p && *p != '/')
        p++;
      if (p == port_start)
        return 0;
      explicit_port = 1;
    }

  path_start = (*p == '/') ? p : 0;

  host = (char *)xmalloc ((host_end - host_start) + 1);
  strncpy (host, host_start, host_end - host_start);
  host[host_end - host_start] = '\0';

  if (port_start)
    {
      const char *port_end = p;
      port = (char *)xmalloc ((port_end - port_start) + 1);
      strncpy (port, port_start, port_end - port_start);
      port[port_end - port_start] = '\0';
    }
  else
    port = 0;

  if (path_start)
    path = savestring (path_start);
  else
    path = savestring ("/v1");

  *hostp = host;
  *portp = port;
  *pathp = path;
  if (explicit_portp)
    *explicit_portp = explicit_port;
  return 1;
}

static char *
baish_http_post (const char *host, const char *port, const char *path, const char *auth_bearer, const char *body);

static char *
baish_http_get (const char *host, const char *port, const char *path, const char *auth_bearer);

static char *
baish_http_post_try_ports (const char *host, const char *port, const char *path, const char *auth_bearer, const char *body)
{
  static const char *fallback_ports[] = { "80", "8000", 0 };
  char *resp;
  int i;

  baish_clear_transport_error ();

  if (port && *port)
    return baish_http_post (host, port, path, auth_bearer, body);

  for (i = 0; fallback_ports[i]; i++)
    {
      resp = baish_http_post (host, fallback_ports[i], path, auth_bearer, body);
      if (resp)
        return resp;
    }

  return 0;
}

static int
baish_http_status_code (const char *resp)
{
  const char *p;
  int code;

  if (resp == 0)
    return 0;
  if (STREQN (resp, "HTTP/", 5) == 0)
    return 0;

  p = strchr (resp, ' ');
  if (p == 0)
    return 0;
  while (*p == ' ')
    p++;

  code = atoi (p);
  return code;
}

static char *
baish_join_api_path (const char *base_path, const char *suffix)
{
  size_t bl;
  size_t sl;
  int need_slash;
  char *out;

  if (base_path == 0)
    base_path = "/v1";
  if (suffix == 0)
    suffix = "/";
  if (*suffix == 0)
    suffix = "/";

  bl = strlen (base_path);
  sl = strlen (suffix);
  need_slash = (bl == 0 || base_path[bl - 1] != '/');

  out = (char *)xmalloc (bl + sl + (need_slash ? 1 : 0) + 1);
  strcpy (out, base_path);
  if (need_slash)
    strcat (out, "/");
  if (*suffix == '/')
    strcat (out, suffix + 1);
  else
    strcat (out, suffix);
  return out;
}

static char *
baish_http_get_try_ports (const char *host, const char *port, const char *path, const char *auth_bearer)
{
  static const char *fallback_ports[] = { "80", "8000", 0 };
  char *resp;
  int i;

  baish_clear_transport_error ();

  if (port && *port)
    return baish_http_get (host, port, path, auth_bearer);

  for (i = 0; fallback_ports[i]; i++)
    {
      resp = baish_http_get (host, fallback_ports[i], path, auth_bearer);
      if (resp)
        return resp;
    }

  return 0;
}

static char *
baish_http_get (const char *host, const char *port, const char *path, const char *auth_bearer)
{
  struct addrinfo hints, *res, *rp;
  int sfd;
  int ga;
  int timeout_sec;
  char *req;
  size_t reqlen;
  char *resp;
  size_t cap, len;
  ssize_t n;

  memset (&hints, 0, sizeof (hints));
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_family = AF_UNSPEC;

  baish_diag ("resolving %s:%s%s", host ? host : "", port ? port : "", path ? path : "");

  ga = getaddrinfo (host, port, &hints, &res);
  if (ga != 0)
    {
      baish_set_transport_error ("getaddrinfo(%s:%s): %s", host ? host : "", port ? port : "", gai_strerror (ga));
      return 0;
    }

  sfd = -1;
  for (rp = res; rp; rp = rp->ai_next)
    {
      sfd = socket (rp->ai_family, rp->ai_socktype, rp->ai_protocol);
      if (sfd < 0)
        continue;

      timeout_sec = baish_http_timeout_seconds ();
      {
        struct timeval tv;
        tv.tv_sec = timeout_sec;
        tv.tv_usec = 0;
        setsockopt (sfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof (tv));
        setsockopt (sfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof (tv));
      }

      baish_diag ("connecting to %s:%s%s", host ? host : "", port ? port : "", path ? path : "");
      if (connect (sfd, rp->ai_addr, rp->ai_addrlen) == 0)
        break;
      baish_set_transport_error ("connect(%s:%s): %s", host ? host : "", port ? port : "", strerror (errno));
      close (sfd);
      sfd = -1;
    }
  freeaddrinfo (res);
  if (sfd < 0)
    return 0;

  if (auth_bearer && *auth_bearer)
    {
      reqlen = strlen (host) + strlen (path) + strlen (auth_bearer) + 128;
      req = (char *)xmalloc (reqlen);
      snprintf (req, reqlen,
                "GET %s HTTP/1.1\r\n"
                "Host: %s\r\n"
                "Authorization: Bearer %s\r\n"
                "Connection: close\r\n"
                "\r\n",
                path, host, auth_bearer);
    }
  else
    {
      reqlen = strlen (host) + strlen (path) + 96;
      req = (char *)xmalloc (reqlen);
      snprintf (req, reqlen,
                "GET %s HTTP/1.1\r\n"
                "Host: %s\r\n"
                "Connection: close\r\n"
                "\r\n",
                path, host);
    }

  {
    const char *p = req;
    size_t left = strlen (req);
    while (left)
      {
        n = write (sfd, p, left);
        if (n <= 0)
          {
            baish_set_transport_error ("write(%s:%s): %s", host ? host : "", port ? port : "", strerror (errno));
            free (req);
            close (sfd);
            return 0;
          }
        p += n;
        left -= (size_t)n;
      }
  }
  free (req);

  cap = 8192;
  len = 0;
  resp = (char *)xmalloc (cap);

  while (1)
    {
      n = read (sfd, resp + len, cap - len - 1);
      if (n > 0)
        {
          len += (size_t)n;
          if (len + 4096 >= cap)
            {
              cap *= 2;
              resp = (char *)xrealloc (resp, cap);
            }
          continue;
        }
      if (n == 0)
        break;
      baish_set_transport_error ("read(%s:%s): %s", host ? host : "", port ? port : "", strerror (errno));
      free (resp);
      close (sfd);
      return 0;
    }

  close (sfd);
  resp[len] = '\0';
  return resp;
}

static char *
baish_http_post (const char *host, const char *port, const char *path, const char *auth_bearer, const char *body)
{
  struct addrinfo hints, *res, *rp;
  int sfd;
  int ga;
  int timeout_sec;
  size_t bodylen;
  char *req;
  size_t reqlen;
  char *resp;
  size_t cap, len;
  ssize_t n;

  memset (&hints, 0, sizeof (hints));
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_family = AF_UNSPEC;

  baish_diag ("resolving %s:%s%s", host ? host : "", port ? port : "", path ? path : "");

  ga = getaddrinfo (host, port, &hints, &res);
  if (ga != 0)
    {
      baish_set_transport_error ("getaddrinfo(%s:%s): %s", host ? host : "", port ? port : "", gai_strerror (ga));
      return 0;
    }

  sfd = -1;
  for (rp = res; rp; rp = rp->ai_next)
    {
      sfd = socket (rp->ai_family, rp->ai_socktype, rp->ai_protocol);
      if (sfd < 0)
        continue;

      timeout_sec = baish_http_timeout_seconds ();
      {
        struct timeval tv;
        tv.tv_sec = timeout_sec;
        tv.tv_usec = 0;
        setsockopt (sfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof (tv));
        setsockopt (sfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof (tv));
      }

      baish_diag ("connecting to %s:%s%s", host ? host : "", port ? port : "", path ? path : "");
      if (connect (sfd, rp->ai_addr, rp->ai_addrlen) == 0)
        break;
      baish_set_transport_error ("connect(%s:%s): %s", host ? host : "", port ? port : "", strerror (errno));
      close (sfd);
      sfd = -1;
    }
  freeaddrinfo (res);
  if (sfd < 0)
    return 0;

  bodylen = body ? strlen (body) : 0;
  if (auth_bearer && *auth_bearer)
    {
      reqlen = bodylen + strlen (host) + strlen (path) + strlen (auth_bearer) + 256;
      req = (char *)xmalloc (reqlen);
      snprintf (req, reqlen,
                "POST %s HTTP/1.1\r\n"
                "Host: %s\r\n"
                "Content-Type: application/json\r\n"
                "Authorization: Bearer %s\r\n"
                "Connection: close\r\n"
                "Content-Length: %lu\r\n"
                "\r\n"
                "%s",
                path, host, auth_bearer, (unsigned long)bodylen, body ? body : "");
    }
  else
    {
      reqlen = bodylen + strlen (host) + strlen (path) + 192;
      req = (char *)xmalloc (reqlen);
      snprintf (req, reqlen,
                "POST %s HTTP/1.1\r\n"
                "Host: %s\r\n"
                "Content-Type: application/json\r\n"
                "Connection: close\r\n"
                "Content-Length: %lu\r\n"
                "\r\n"
                "%s",
                path, host, (unsigned long)bodylen, body ? body : "");
    }

  {
    const char *p = req;
    size_t left = strlen (req);
    while (left)
      {
        n = write (sfd, p, left);
        if (n <= 0)
          {
            baish_set_transport_error ("write(%s:%s): %s", host ? host : "", port ? port : "", strerror (errno));
            free (req);
            close (sfd);
            return 0;
          }
        p += n;
        left -= (size_t)n;
      }
  }
  free (req);

  cap = 8192;
  len = 0;
  resp = (char *)xmalloc (cap);

  while (1)
    {
      n = read (sfd, resp + len, cap - len - 1);
      if (n > 0)
        {
          len += (size_t)n;
          if (len + 4096 >= cap)
            {
              cap *= 2;
              resp = (char *)xrealloc (resp, cap);
            }
          continue;
        }
      if (n == 0)
        break;
      baish_set_transport_error ("read(%s:%s): %s", host ? host : "", port ? port : "", strerror (errno));
      free (resp);
      close (sfd);
      return 0;
    }

  close (sfd);
  resp[len] = '\0';
  return resp;
}

static char *
baish_http_body (const char *resp)
{
  const char *p, *body;
  char *headers;
  char *decoded;

  p = resp ? strstr (resp, "\r\n\r\n") : 0;
  if (p == 0)
    return 0;

  {
    size_t hlen = (size_t)(p - resp);
    headers = (char *)xmalloc (hlen + 1);
    memcpy (headers, resp, hlen);
    headers[hlen] = '\0';
  }
  body = p + 4;

  decoded = 0;
  if (headers && (baish_strcasestr (headers, "Transfer-Encoding: chunked") != 0))
    {
      const char *bp = body;
      size_t cap = 4096;
      size_t len = 0;

      decoded = (char *)xmalloc (cap);
      while (bp && *bp)
        {
          unsigned long chunk;
          char *endp;

          chunk = strtoul (bp, &endp, 16);
          if (endp == (char *)bp)
            { free (decoded); decoded = 0; break; }

          bp = strstr (endp, "\r\n");
          if (bp == 0)
            { free (decoded); decoded = 0; break; }
          bp += 2;

          if (chunk == 0)
            break;

          if (len + chunk + 1 >= cap)
            {
              while (len + chunk + 1 >= cap)
                cap *= 2;
              decoded = (char *)xrealloc (decoded, cap);
            }

          memcpy (decoded + len, bp, chunk);
          len += chunk;
          bp += chunk;

          if (bp[0] == 0 || bp[1] == 0 || bp[0] != '\r' || bp[1] != '\n')
            { free (decoded); decoded = 0; break; }
          bp += 2;
        }

      if (decoded)
        decoded[len] = '\0';
    }

  free (headers);
  if (decoded)
    return decoded;
  return savestring (body);
}

static char *
baish_extract_error_message (const char *json)
{
  const char *p;

  if (json == 0)
    return 0;

  p = strstr (json, "\"error\"");
  if (p)
    p = strstr (p, "\"message\"");
  if (p == 0)
    p = strstr (json, "\"message\"");
  if (p == 0)
    return 0;

  p = strchr (p, ':');
  if (p == 0)
    return 0;
  p++;
  p = baish_skip_ws (p);
  if (*p != '"')
    return 0;

  return baish_json_parse_string (&p);
}

static int
baish_extract_model_ids (const char *json, char ***idsp, int *nids)
{
  const char *p;
  char **ids;
  int n;
  int cap;

  if (json == 0 || idsp == 0 || nids == 0)
    return 0;

  p = json;
  ids = 0;
  n = 0;
  cap = 0;

  while ((p = strstr (p, "\"id\"")) != 0)
    {
      p = strchr (p, ':');
      if (p == 0)
        break;
      p++;
      p = baish_skip_ws (p);
      if (*p != '"')
        {
          if (*p)
            p++;
          continue;
        }

      {
        char *id;
        id = baish_json_parse_string (&p);
        if (id == 0)
          break;
        if (cap == 0)
          {
            cap = 16;
            ids = (char **)xmalloc (cap * sizeof (char *));
          }
        if (n >= cap)
          {
            cap *= 2;
            ids = (char **)xrealloc (ids, cap * sizeof (char *));
          }
        ids[n++] = id;
        if (n >= 200)
          break;
      }
    }

  if (n == 0)
    {
      if (ids)
        free (ids);
      return 0;
    }

  *idsp = ids;
  *nids = n;
  return 1;
}

static void
baish_free_string_list (char **s, int n)
{
  int i;
  if (s == 0)
    return;
  for (i = 0; i < n; i++)
    if (s[i])
      free (s[i]);
  free (s);
}

static void
baish_print_llm_env_help (void)
{
  fprintf (stderr, "baish: configure the LLM with environment variables:\n");
  fprintf (stderr, "  export BAISH_OPENAI_BASE_URL=HOST[:PORT][/v1]   # or http://HOST[:PORT][/v1] (no https)\n");
  fprintf (stderr, "  export BAISH_MODEL=MODEL_ID\n");
  fprintf (stderr, "  export OPENAI_API_KEY=...                     # optional\n");
  fprintf (stderr, "  export BAISH_FAIL_FAST=1                      # optional preflight\n");
  fprintf (stderr, "  export BAISH_HTTP_TIMEOUT_SECS=15             # optional transport timeout\n");
}

static char *
baish_extract_message_content (const char *json)
{
  const char *p;

  if (json == 0)
    return 0;

  p = strstr (json, "\"message\"");
  if (p)
    p = strstr (p, "\"content\"");
  if (p == 0)
    p = strstr (json, "\"content\"");
  if (p == 0)
    return 0;

  p = strchr (p, ':');
  if (p == 0)
    return 0;
  p++;
  p = baish_skip_ws (p);
  if (*p != '"')
    return 0;

  return baish_json_parse_string (&p);
}

static int
baish_parse_answer_commands (const char *s, char **answerp, char ***cmdsp, int *ncmdsp)
{
  const char *p;
  char *answer;
  char **cmds;
  int ncmds;
  int i;

  answer = 0;
  cmds = 0;
  ncmds = 0;

  if (s == 0)
    return 0;

  p = strchr (s, '{');
  if (p == 0)
    return 0;
  p++;

  while (*p)
    {
      char *key;

      p = baish_skip_ws (p);
      if (*p == '}')
        break;
      if (*p == ',')
        {
          p++;
          continue;
        }
      if (*p != '"')
        goto fail;

      key = baish_json_parse_string (&p);
      if (key == 0)
        goto fail;

      p = baish_skip_ws (p);
      if (*p != ':')
        {
          free (key);
          goto fail;
        }
      p++;
      p = baish_skip_ws (p);

      if (STREQ (key, "answer"))
        {
          free (key);
          if (*p != '"')
            goto fail;
          if (answer)
            free (answer);
          answer = baish_json_parse_string (&p);
          if (answer == 0)
            goto fail;
        }
      else if (STREQ (key, "commands"))
        {
          int cap = 4;

          free (key);
          if (*p != '[')
            goto fail;
          p++;
          if (cmds)
            {
              for (i = 0; i < ncmds; i++)
                if (cmds[i])
                  free (cmds[i]);
              free (cmds);
            }
          cmds = (char **)xmalloc (cap * sizeof (char *));
          ncmds = 0;

          while (*p)
            {
              p = baish_skip_ws (p);
              if (*p == ']')
                { p++; break; }
              if (*p == ',')
                { p++; continue; }
              if (*p != '"')
                goto fail;
              if (ncmds >= cap)
                {
                  cap *= 2;
                  cmds = (char **)xrealloc (cmds, cap * sizeof (char *));
                }
              cmds[ncmds++] = baish_json_parse_string (&p);
              if (cmds[ncmds-1] == 0)
                goto fail;
            }
        }
      else
        {
          free (key);
          if (*p == '"')
            {
              char *tmp = baish_json_parse_string (&p);
              if (tmp)
                free (tmp);
            }
          else
            {
              while (*p && *p != ',' && *p != '}')
                p++;
            }
        }
    }

  if (answer == 0)
    answer = savestring (s);

  *answerp = answer;
  *cmdsp = cmds;
  *ncmdsp = ncmds;
  return 1;

fail:
  if (answer)
    free (answer);
  if (cmds)
    {
      for (i = 0; i < ncmds; i++)
        if (cmds[i])
          free (cmds[i]);
      free (cmds);
    }
  return 0;
}

static char *
baish_join_commands (char **cmds, int ncmds)
{
  int i;
  size_t cap, len;
  char *out;

  if (ncmds <= 0)
    return savestring ("");

  cap = 1;
  for (i = 0; i < ncmds; i++)
    cap += strlen (cmds[i]) + 1;

  out = (char *)xmalloc (cap);
  len = 0;
  for (i = 0; i < ncmds; i++)
    {
      size_t l = strlen (cmds[i]);
      memcpy (out + len, cmds[i], l);
      len += l;
      out[len++] = (i == ncmds - 1) ? '\0' : '\n';
    }
  out[len] = '\0';
  return out;
}

static int
baish_confirm_exec (int ncmds)
{
  char buf[32];

  if (interactive_shell == 0)
    return 0;
  if (isatty (fileno (stdin)) == 0)
    return 0;

  fprintf (stderr, "baish: execute %d command(s)? [y/N] ", ncmds);
  fflush (stderr);
  if (fgets (buf, sizeof (buf), stdin) == 0)
    return 0;
  return (buf[0] == 'y' || buf[0] == 'Y');
}

int
ask_builtin (WORD_LIST *list)
{
  char *question;
  char *escaped;
  char *body;
  char *host, *port, *base_path;
  char *path;
  char *resp;
  char *json;
  char *content;
  char *answer;
  char **cmds;
  int ncmds;
  char *joined;
  int i;
  int do_exec;
  int status;

  char *models_path;
  char **models;
  int nmodels;
  int have_models;

  const char *base_url = get_string_value ("BAISH_OPENAI_BASE_URL");
  const char *port_override = get_string_value ("BAISH_OPENAI_PORT");
  const char *model = get_string_value ("BAISH_MODEL");
  const char *autoexec = get_string_value ("BAISH_AUTOEXEC");
  const char *fail_fast = get_string_value ("BAISH_FAIL_FAST");
  const char *api_key = get_string_value ("OPENAI_API_KEY");
  int explicit_port;

  models_path = 0;
  models = 0;
  nmodels = 0;
  have_models = 0;

  if (base_url == 0)
    base_url = get_string_value ("OPENAI_BASE_URL");

  if (model == 0)
    model = get_string_value ("OPENAI_MODEL");

  if (base_url == 0)
    {
      bind_variable ("BAISH_LAST_ANSWER", "", 0);
      bind_variable ("BAISH_LAST_COMMANDS", "", 0);
      builtin_error (_("BAISH_OPENAI_BASE_URL is not set"));
      baish_print_llm_env_help ();
      return (EXECUTION_FAILURE);
    }

  if (list)
    {
      size_t cap = 0;
      size_t len = 0;
      WORD_LIST *t;
      char *q;

      for (t = list; t; t = t->next)
        cap += strlen (t->word->word) + 1;
      q = (char *)xmalloc (cap + 1);
      for (t = list; t; t = t->next)
        {
          size_t l = strlen (t->word->word);
          memcpy (q + len, t->word->word, l);
          len += l;
          if (t->next)
            q[len++] = ' ';
        }
      q[len] = '\0';
      question = q;
    }
  else
    {
      size_t qlen;
      question = baish_slurp_stream (stdin, &qlen);
      if (qlen == 0)
        {
          free (question);
	  builtin_error (_("missing question"));
          return (EXECUTION_FAILURE);
        }
    }

  host = port = base_path = 0;
  explicit_port = 0;
  if (baish_parse_http_base_url (base_url, &host, &port, &base_path, &explicit_port) == 0)
    {
	  builtin_error (_("BAISH_OPENAI_BASE_URL must be host[:port][/v1] or http://host[:port][/v1] (no https)"));
      free (question);
      return (EXECUTION_FAILURE);
    }

  if (explicit_port == 0 && port_override && *port_override)
    {
      if (port)
        free (port);
      port = savestring (port_override);
    }

  path = baish_join_api_path (base_path, "/chat/completions");
  models_path = baish_join_api_path (base_path, "/models");

  if (model == 0 || *model == 0)
    {
      char *mresp;
      char *mbody;
      int mstatus;

      bind_variable ("BAISH_LAST_ANSWER", "", 0);
      bind_variable ("BAISH_LAST_COMMANDS", "", 0);
      builtin_error (_("BAISH_MODEL is not set"));

      mresp = baish_http_get_try_ports (host, port, models_path, api_key);
      if (mresp)
        {
          mstatus = baish_http_status_code (mresp);
          mbody = baish_http_body (mresp);
          free (mresp);
          if (mbody && mstatus == 200)
            {
              if (baish_extract_model_ids (mbody, &models, &nmodels))
                have_models = 1;
            }
          if (mbody)
            free (mbody);
        }

      if (have_models)
        {
          int j;
          int limit;
          fprintf (stderr, "baish: models reported by the API (%d):\n", nmodels);
          limit = (nmodels > 50) ? 50 : nmodels;
          for (j = 0; j < limit; j++)
            fprintf (stderr, "  %s\n", models[j]);
          if (nmodels > limit)
            fprintf (stderr, "  ... (%d more)\n", nmodels - limit);
        }
      else if (baish_transport_error[0])
        fprintf (stderr, "baish: could not list models (%s)\n", baish_transport_error);

      baish_print_llm_env_help ();
      free (question);
      free (host);
      if (port) free (port);
      free (base_path);
      free (path);
      if (models_path) free (models_path);
      baish_free_string_list (models, nmodels);
      return (EXECUTION_FAILURE);
    }

  if (baish_truthy (fail_fast))
    {
      char *pre;
      char *pbody;
      int pstatus;

      pre = baish_http_get_try_ports (host, port, models_path, api_key);
      if (pre == 0)
        {
          bind_variable ("BAISH_LAST_ANSWER", "", 0);
          bind_variable ("BAISH_LAST_COMMANDS", "", 0);
          if (baish_transport_error[0])
            builtin_error (_("fail-fast preflight failed: %s"), baish_transport_error);
          else
            builtin_error (_("fail-fast preflight failed (cannot reach LLM)"));
          baish_print_llm_env_help ();
          free (question);
          free (host);
          if (port) free (port);
          free (base_path);
          free (path);
          free (models_path);
          baish_free_string_list (models, nmodels);
          return (EXECUTION_FAILURE);
        }

      pstatus = baish_http_status_code (pre);
      pbody = baish_http_body (pre);
      free (pre);
      if (pbody == 0 || pstatus != 200)
        {
          char *em;
          bind_variable ("BAISH_LAST_ANSWER", "", 0);
          bind_variable ("BAISH_LAST_COMMANDS", "", 0);
          em = baish_extract_error_message (pbody);
          if (em)
            {
              builtin_error (_("fail-fast preflight failed (HTTP %d): %s"), pstatus, em);
              free (em);
            }
          else
            builtin_error (_("fail-fast preflight failed (HTTP %d)"), pstatus);
          if (pbody)
            free (pbody);
          baish_print_llm_env_help ();
          free (question);
          free (host);
          if (port) free (port);
          free (base_path);
          free (path);
          free (models_path);
          baish_free_string_list (models, nmodels);
          return (EXECUTION_FAILURE);
        }

      if (baish_extract_model_ids (pbody, &models, &nmodels))
        have_models = 1;
      free (pbody);
    }

  escaped = baish_json_escape (question);
  body = (char *)xmalloc (strlen (escaped) + strlen (model) + 1024);
  sprintf (body,
           "{"
           "\"model\":\"%s\","
           "\"stream\":false,"
           "\"messages\":["
           "{\"role\":\"system\",\"content\":\"You are baish, an interactive shell assistant. Reply with strict JSON only: {\\\"answer\\\":string,\\\"commands\\\":[string,...]}. Put any shell commands to run into commands; otherwise commands should be []. Do not include any other text.\"},"
           "{\"role\":\"user\",\"content\":\"%s\"}"
           "]"
           "}",
           model, escaped);

  resp = baish_http_post_try_ports (host, port, path, api_key, body);
  free (question);
  free (escaped);
  free (body);
  question = 0;

  if (resp == 0)
    {
      bind_variable ("BAISH_LAST_ANSWER", "", 0);
      bind_variable ("BAISH_LAST_COMMANDS", "", 0);
	  if (baish_transport_error[0])
	    builtin_error (_("request failed: %s"), baish_transport_error);
	  else
	    builtin_error (_("request failed (cannot reach LLM)"));
	  baish_print_llm_env_help ();
	  free (host);
	  if (port) free (port);
	  free (base_path);
	  free (path);
	  if (models_path) free (models_path);
	  baish_free_string_list (models, nmodels);
      return (EXECUTION_FAILURE);
    }

  {
    int http_status;
    http_status = baish_http_status_code (resp);

    json = baish_http_body (resp);
    free (resp);
    resp = 0;

    if (json == 0)
      {
        bind_variable ("BAISH_LAST_ANSWER", "", 0);
        bind_variable ("BAISH_LAST_COMMANDS", "", 0);
        builtin_error (_("invalid HTTP response"));
        baish_print_llm_env_help ();
        free (host);
        if (port) free (port);
        free (base_path);
        free (path);
        if (models_path) free (models_path);
        baish_free_string_list (models, nmodels);
        return (EXECUTION_FAILURE);
      }

    if (http_status != 200)
      {
        char *em;
        int model_error;

        em = baish_extract_error_message (json);
        model_error = 0;
        if (em && baish_strcasestr (em, "model") && (baish_strcasestr (em, "not") || baish_strcasestr (em, "exist") || baish_strcasestr (em, "found")))
          model_error = 1;

        bind_variable ("BAISH_LAST_ANSWER", "", 0);
        bind_variable ("BAISH_LAST_COMMANDS", "", 0);
        if (em)
          {
            builtin_error (_("LLM error (HTTP %d): %s"), http_status, em);
            free (em);
          }
        else
          builtin_error (_("LLM error (HTTP %d)"), http_status);

        if (model_error)
          {
            if (have_models == 0)
              {
                char *mresp;
                char *mbody;
                int mstatus;

                mresp = baish_http_get_try_ports (host, port, models_path, api_key);
                if (mresp)
                  {
                    mstatus = baish_http_status_code (mresp);
                    mbody = baish_http_body (mresp);
                    free (mresp);
                    if (mbody && mstatus == 200)
                      {
                        if (baish_extract_model_ids (mbody, &models, &nmodels))
                          have_models = 1;
                      }
                    if (mbody)
                      free (mbody);
                  }
              }

            if (have_models)
              {
                int j;
                int limit;
                fprintf (stderr, "baish: BAISH_MODEL=%s\n", model);
                fprintf (stderr, "baish: models reported by the API (%d):\n", nmodels);
                limit = (nmodels > 50) ? 50 : nmodels;
                for (j = 0; j < limit; j++)
                  fprintf (stderr, "  %s\n", models[j]);
                if (nmodels > limit)
                  fprintf (stderr, "  ... (%d more)\n", nmodels - limit);
              }
            else
              fprintf (stderr, "baish: could not list models from %s (GET %s)\n", base_url, models_path);
          }
        else
          {
            ;
          }

        free (json);
        free (host);
        if (port) free (port);
        free (base_path);
        free (path);
        if (models_path) free (models_path);
        baish_free_string_list (models, nmodels);
        return (EXECUTION_FAILURE);
      }
  }

  content = baish_extract_message_content (json);
  free (json);
  if (content == 0)
    {
      bind_variable ("BAISH_LAST_ANSWER", "", 0);
      bind_variable ("BAISH_LAST_COMMANDS", "", 0);
	  builtin_error (_("could not parse response"));
	  free (host);
	  if (port) free (port);
	  free (base_path);
	  free (path);
	  if (models_path) free (models_path);
	  baish_free_string_list (models, nmodels);
      return (EXECUTION_FAILURE);
    }

  answer = 0;
  cmds = 0;
  ncmds = 0;
  if (baish_parse_answer_commands (content, &answer, &cmds, &ncmds) == 0)
    {
      answer = savestring (content);
      cmds = 0;
      ncmds = 0;
    }
  free (content);

  joined = baish_join_commands (cmds, ncmds);
  bind_variable ("BAISH_LAST_ANSWER", answer, 0);
  bind_variable ("BAISH_LAST_COMMANDS", joined, 0);

  printf ("%s\n", answer);
  fflush (stdout);

  do_exec = 0;
  if (ncmds > 0)
    {
      if (baish_truthy (autoexec))
        do_exec = 1;
      else
        {
          int j;
          for (j = 0; j < ncmds; j++)
            fprintf (stderr, "baish: command[%d]: %s\n", j + 1, cmds[j]);
          do_exec = baish_confirm_exec (ncmds);
        }
    }

  status = EXECUTION_SUCCESS;
  if (do_exec)
    {
      for (i = 0; i < ncmds; i++)
        {
          int r;
          r = parse_and_execute (savestring (cmds[i]), "ask", SEVAL_NOHIST|SEVAL_RESETLINE);
          status = r;
        }
    }

  if (cmds)
    {
      for (i = 0; i < ncmds; i++)
        if (cmds[i])
          free (cmds[i]);
      free (cmds);
    }
  free (joined);
  free (answer);

  free (host);
  if (port)
    free (port);
  free (base_path);
  free (path);
  if (models_path)
    free (models_path);
  baish_free_string_list (models, nmodels);

  return status;
}
